---
title: "MB5370 Module 04. Workshop 1 - Introduction"
author: "Saville Wall"
output: html_document
date: "2024-08-26"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Install and load tidyverse packages
```{r}
# install.packages("tidyverse") # Delete this line once installed
library("tidyverse")

```


# Load the data (mpg is built into ggplot2)
```{r}
data(mpg)
```


# Quick data checks
```{r}
head(mpg)
glimpse(mpg)
summary(mpg)
```


# Create first plot
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))
```

The plot shows a negative relationship between engine size (displ) and fuel efficiency (hwy). In other words, cars with big engines use more fuel. What does this say about fuel efficiency and engine size?

The larget the engine, the less fuel efficient it will be.



# Understanding grammar of graphics
What happens if we just try to run ggplot on its own?

it simply creates a blank plot
```{r}
ggplot() 
# Or with just the data specified?
ggplot(data = mpg)
```

We need to map some aesthetics!!

# When youâ€™re creating a plot, you essentially need two attributes of a plot: a geom and aesthetics.
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, colour = class))
```


# Change point colour by class:
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, colour = class))
```

# Change point size by class:
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, size = class))
```
Note the warning!!!
"Warning: [38;5;232mUsing [32msize[38;5;232m for a discrete variable is not advised.[39m"


# Change transparency (alpha) by class
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, alpha = class))
```
Another warning!!
"Warning: [38;5;232mUsing alpha for a discrete variable is not advised.[39m"
Question: When would using alpha (or size be appropriate??)

# Change point shape by class:
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, shape = class))
```
"Warning: [38;5;232mThe shape palette can deal with a maximum of 6 discrete values because more than 6 becomes difficult to discriminate [36mâ„¹[38;5;232m you have requested 7 values. Consider specifying shapes manually if you need that many have them.[39m
Warning: [38;5;232mRemoved 62 rows containing missing values or values outside the scale range (`geom_point()`).[39m"

# Make all points blue
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue")
```
What happens if you map an aesthetic to something other than a variable name?

error, this isnt a color
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "displ < 5")
```


# Troubleshooting 

```{r}
#ggplot(data = mpg) 
#+ geom_point(mapping = aes(x = displ, y = hwy)) 
# the + should be on top line so it will say "Error in `+.gg`(geom_point(mapping = aes(x = displ, y = hwy))) : Did you accidentally put `+` on a new line?"
```

# Faceting

## facet_wrap
Split the plot out by car type (class)
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_wrap(~ class, nrow = 2)
```


## facet_grid
A separate facet for each combination of drive-type (e.g. 4WD) * number of cylinders
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_grid(drv ~ cyl)
```
Note that there are no occurrences of 5 cylinder 4WDs OR RWD vehicles!


## facet_grid by just row (or column)
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_grid(cyl ~ .)
  #facet_grid(. ~ cyl) # Alternatively

```

# Exercise:
Read ?facet_wrap. What does nrow do? What does ncol do? What other options control the layout of the individual panels? 

```{r}
?facet_wrap
#nrow means number of rows, ncol means number of columns... you can also change the scales, change the labeling, axes, etc.
```


# Lines
We already used points:
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))
```


However, ggplot2 can use a variety of geom objects to represent the data. Here, we might want to use bar plots, line charts, boxplots and so on. Well we can handle this issue in ggplot directly using a different geom to plot the same data. Here, instead of plotting points, we will use a smooth line. 

# To display the same data as a smooth line fit through the points use geom_smooth().
```{r}
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy))
```
### Question: whey don't we use geom_line() here? What would that look like? ###
Line connects all the points instead of creating a smooth average line like we have from geom_smooth.

So letâ€™s recap. A geom is an object that your plot uses to represent the data. To change the geom type in your plot, simply change the geom function that you add to your plot template. Sometimes you may want to try a few things out, in which case you could use comments to help you remember what worked and what didnâ€™t. 

## Using comments (#)
```{r}
ggplot(data = mpg) + 
  #geom_point(mapping = aes(x = displ, y = hwy)) + # points horrible 
  geom_smooth(mapping = aes(x = displ, y = hwy)) # try smooth line
```

Question: how does R work out where to plot the line??? Can use the chunk output to inform us. Can also use the help menu.
"[38;5;232m`geom_smooth()` using method = 'loess' and formula = 'y ~ x'[39m"

# Changing linetype
```{r}
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv)) # Can also use "lty = " for the same result
```


# Grouping
```{r}
ggplot(data = mpg) +
  geom_smooth(mapping = aes(x = displ, y = hwy, group = drv))
```
 
# Change line colour based on drv value
```{r}
ggplot(data = mpg) +
  geom_smooth(
    mapping = aes(x = displ, y = hwy, color = drv),
    show.legend = FALSE,
  )
```

# Multiple geoms
We already did this one way
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  geom_smooth(mapping = aes(x = displ, y = hwy))
```

A better way...
```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth()
```


# Can still manipulate each geom/layer separately:
```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) + 
  geom_smooth()
```

Now we have different colours to indicate the raw data (geom_point) and one colour for the overall relationship (geom_smooth). Neat!


```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) + 
  geom_smooth(data = filter(mpg, class == "subcompact"), se = FALSE)
```
Question: what does the "se = FALSE" do?
it gets rid of the standard error shading surrounding the smooth line. = TRUE would bring it back

# Exercise:
1.  What geom would you use to draw a line chart? A boxplot? A histogram? An area chart?
2.  Run this code in your head and predict what the output will look like. Then, run the code in R and check your predictions.

```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_line()
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_boxplot()
ggplot(data = mpg, mapping = aes(x = displ)) + 
  geom_histogram()
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_area()
```


3.  Will these two graphs look different? Why/why not?
no, they're the same graphs just written in a different format, the first way is just a more concise way of writing the second
```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth()

ggplot() + 
  geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy))
```


# Transformations and stats

## Load data
```{r}
data("diamonds")
glimpse(diamonds)
```

# Bar plot
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut))
```

# Overriding defaults
Make some new data
```{r}
demo <- tribble(
  ~cut,         ~freq,
  "Fair",       1610,
  "Good",       4906,
  "Very Good",  12082,
  "Premium",    13791,
  "Ideal",      21551
)
demo
```


```{r}
ggplot(data = demo) +
  geom_bar(mapping = aes(x = cut, y = freq), stat = "identity")
```
Question: Why did we specify now specify a y axis?
because its frequency instead of count

# What if we want to know the proportion rather than the absolute frequency?
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, y = after_stat(prop), group = 1))
```

Question: does anyone get the warning that's in the workbook?
Warning: `stat(prop)` was deprecated in ggplot2 3.4.0.
If so, can use # geom_bar(mapping = aes(x = cut, y = stage(after_stat = prop), group = 1))

yes, changed it to after_stat

# Plotting statistical details
```{r}
ggplot(data = diamonds) + 
  stat_summary(
    mapping = aes(x = cut, y = depth),
    fun.min = min,
    fun.max = max,
    fun = median
  )
```


# Aesthetic adjustments adjustments
Another way to boost the way you can convey information with plots using ggplot2 is to use aesthetics like colour or fill to change aspects of bar colours. We already did this once, but there are multiple options available to you, including changing the fill our outline colours.

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, colour = cut))
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = cut))
```
Question: Does anyone notice anything different in the colour scheme of this plot?

it uses colors people with colorblindness can tell apart easily

(Hint: It's in the viridis colour palette (colour blind friendly), but why is it different from the colour palette we used earlier?)
Check out the difference:
```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) 

ggplot(data = diamonds, mapping = aes(x = color, y = depth)) + 
  geom_point(mapping = aes(color = cut)) 
```


# Filling by a variable
Now try using these aesthetics to colour by another variable like clarity. Notice how the stacking is done automatically. This is done behind the scenes with a position argument.
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity))
```


# To alter transparency (alpha)
```{r}
ggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) + 
  geom_bar(alpha = 1/5, position = "identity")
```


# To color the bar outlines with no fill color
```{r}
ggplot(data = diamonds, mapping = aes(x = cut, colour = clarity)) + 
  geom_bar(fill = NA, position = "identity")
```


# Position adjustments
position = "fill" works like stacking, but makes each set of stacked bars the same height.
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "fill")
```


# position = "dodge" 
Places overlapping objects directly beside one another.
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "dodge")
```

# Jittering
position = "jitter" adds a small amount of random noise to each point to avoid overplotting when points overlap. This is useful for scatterplots but not barplots.
```{r}
ggplot(data = mpg) + 
  #geom_point(mapping = aes(x = displ, y = hwy), position = "jitter")
  geom_point(mapping = aes(x = displ, y = hwy))
```
#### Workshop 2 -------------------------------------------------------------------------------------####
# Labeling
labs function to give title, subtitle, caption, etc.
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  labs(title = "Fuel efficiency generally decreases with engine size")

#can also use subtitles and captions
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  labs(
    title = "Fuel efficiency generally decreases with engine size",
    subtitle = "Two seaters (sports cars) are an exception because of their light weight",
    caption = "Data from fueleconomy.gov"
  )

# we can also change the x and y labels
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  geom_smooth(se = FALSE) +
  labs(
    x = "Engine displacement (L)",
    y = "Highway fuel economy (mpg)",
    colour = "Car type"
  )

```

# Annotations
```{r}
best_in_class <- mpg %>%
  group_by(class) %>%
  filter(row_number(desc(hwy)) == 1)

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  geom_text(aes(label = model), data = best_in_class)
# this includes words over certain points.. for this graph it doesnt quite work, they overlap. we may want to use a function like nudge()
```

# Scales
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) # this follows the default scale that ggplot uses

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  scale_x_continuous() +   # if we look at ?scale_x_continuous we can see other options for these scales, same for y.
  scale_y_continuous() +
  scale_colour_discrete()

```

# Axis Ticks
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  scale_y_continuous(breaks = seq(15, 40, by = 5))
# seq means that the y axis goes from 15 to 40, going up by 5 each time.

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  scale_x_continuous(labels = NULL) + # NULL gets rid of the tick labels all together, no more numbers on the sides.
  scale_y_continuous(labels = NULL)


```

# Legends and Color Schemes
```{r}
base <- ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class))

base + theme(legend.position = "left")
base + theme(legend.position = "top")
base + theme(legend.position = "bottom")
base + theme(legend.position = "right") # the default

#each one of these changes the position of the legend as it says
```

# Replacing a Scale
```{r}
ggplot(diamonds, aes(carat, price)) +
  geom_bin2d() + 
  scale_x_log10() + 
  scale_y_log10() #used if we log transform data

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = drv))
# we can change the color scale
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = drv)) +
  scale_colour_brewer(palette = "Set1")

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = drv, shape = drv)) + # this one adds shape so that even in black and white you can still differentiate the groups
  scale_colour_brewer(palette = "Set1")

presidential %>%
  mutate(id = 33 + row_number()) %>%
  ggplot(aes(start, id, colour = party)) +
    geom_point() +
    geom_segment(aes(xend = end, yend = id)) +
    scale_colour_manual(values = c(Republican = "red", Democratic = "blue")) #if you want to use preset colors you can do that!


```

# Virdis Color scheme
```{r}
#install.packages('viridis')
#install.packages('hexbin')
#library(viridis)
#library(hexbin)

#df <- tibble( # note we're just making a fake dataset so we can plot it
#  x = rnorm(10000),
#  y = rnorm(10000)
#)
#ggplot(df, aes(x, y)) +
#  geom_hex() + # a new geom!
#  coord_fixed()

#ggplot(df, aes(x, y)) +
#  geom_hex() +
#  viridis::scale_fill_viridis() +
#  coord_fixed()

```

# Themes
```{r}

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_bw() #black axis, very light gridlines


ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_light() # light gridlines, grey axis


ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_classic() # good no grid lines, black axis


ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_dark() #dark background for graph and legend

# OR you can develop your own theme:
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme (panel.border = element_blank(),
        panel.grid.minor.x = element_blank(),
        panel.grid.minor.y = element_blank(),
        legend.position="bottom",
        legend.title=element_blank(),
        legend.text=element_text(size=8),
        panel.grid.major = element_blank(),
        legend.key = element_blank(),
        legend.background = element_blank(),
        axis.text.y=element_text(colour="black"),
        axis.text.x=element_text(colour="black"),
        text=element_text(family="Arial")) 



```

# Saving and exporting your plots
```{r}
ggplot(mpg, aes(displ, hwy)) + geom_point()

ggsave("my-plot.pdf")
#> Saving 7 x 4.32 in image

```

